from __future__ import unicode_literals
import os
import imp
import shlex
import prettytable
from ConfigParser import ConfigParser

from prompt_toolkit import prompt
from prompt_toolkit.completion import WordCompleter

from .service import Service
from core.util import safeGetAttr
from core.nlog import NLog

class ExploitService(Service):
    def __init__(self):
        gc = ConfigParser()
        gc.read("/app/config/general.cfg")
        self.exppath = gc.get("GENERAL", "EXP_PATH")
        #self.exppath = "/app/exploits/"
        self.exps = {}
        self.log = None

    def name(self):
        return "exploit"

    def description(self):
        return "Exploit services"

    def stop(self):
        self.log.info("Service Exploit stopped.")
        pass

    def start(self, *args, **kwargs):
        self.log = NLog(self.name())
        self.log.info("Service Exploit inited.")
        self.loadAllExps()

    def setDaemon(self, *args, **kwargs):
        pass

    def make_parser(self, superparser):
        if not superparser:
            msg = "Need to give super parser"
            self.log.error(msg)
            return
        subp = superparser.add_parser(self.name(), help=self.description)
        subp.add_argument("action", type=str, help="service action")

    def do(self, action):
        if action == "show":
            self.printExps()
        elif action == "reload":
            c = WordCompleter(self.getExps)
            p = prompt("Which exp you want to reload:\n>> ", completer=c)
            exps = shlex.split(p)
            msg = "reload: " + str(exps)
            self.log.info(msg)
            self.reload(exps)
        else:
            msg = "Unrecognized action for service {}: {}".format(self.name(), action)
            print(msg)
            self.log.error(msg)

    def getExps(self):
        explist = []
        for f in os.listdir(self.exppath):
            if os.path.isfile(self.exppath + os.sep + f):
                if f[-3:] == ".py":
                    explist.append(f[:-3])
        return explist

    def loadExp(self, exp_name):
        """
        Load an exploit and return an exploit object.

        Args:
            exp_name: Script name of the exploit

        Returns:
            An exploit module if success, otherwise None.
        """
        try:
            exp_path = "{base}{fn}.py".format(base=self.exppath, fn=exp_name)
            mod = imp.load_source(exp_name, exp_path)
            obj = mod.Exploit()
            return mod
            #return obj 
        except Exception as e:
            msg = "Cannot load exploit `{exp_name}`".format(exp_name=exp_name)
            self.log.error(msg)
            print e
            return None

    def loadAllExps(self):
        self.exps = []
        exists_exps = self.getExps()
        ret = {}
        for exp in exists_exps:
            e = self.loadExp(exp)
            if e.Exploit().target in ret:
                ret[e.Exploit().target].append(e)
            else:
                ret[e.Exploit().target] = [e]
        for t in ret:
            ret[t].sort(key=lambda x: x.Exploit().level, reverse=True)
        self.exps = ret

    def printExps(self):
        x = lambda x,y: safeGetAttr(x,y)
        exp_list = []
        for k in self.exps:
            exp_list.extend(self.exps[k])
        pt = prettytable.PrettyTable(["file", "target", "author", "level", "timeout"])
        for exp in exp_list:
            pt.add_row([
                x(exp.Exploit(), "fname"),
                x(exp.Exploit(), "target"),
                x(exp.Exploit(), "author"),
                x(exp.Exploit(), "level"),
                x(exp.Exploit(), "timeout")
            ])
        print(pt)

    def getExpNameByPath(self, s):
        bname = os.path.basename(s)
        if bname.endswith(".py"):
            return bname[:-3]
        if bname.endswith(".pyc"):
            return bname[:-4]

    def reload(self, targets=[]):
        if 'all' in targets:
            self.loadAllExps()
            return

        for e in targets:
            for target in self.exps:
                l = self.exps[target]
                found = 0
                for ee in l:
                    if e == self.getExpNameByPath(ee.Exploit().fname):
                        self.exps[target].remove(ee)
                        self.exps[target].append(
                            self.loadExp(e)
                        )
                        self.exps[target].sort(key=lambda x: x.Exploit().level, reverse=True)
                        found = 1
                        break
                if found == 0:
                    msg = "Unable to find exploit {}".format(e)
                    print msg
                    self.log.error(e)
        return

    def getExpByTarget(self, target):
        return self.exps[target] if target in self.exps else []

    def get_exp_names(self):
        ret = []
        for k in self.exps:
            for exp in self.exps[k]:
                ret.append(exp.name())
        return ret
